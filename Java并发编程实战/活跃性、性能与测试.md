## 避免活跃性危险

### 死锁

当一个线程永远地持有一个锁，并且其他线程都尝试获得这个锁时，那么它将永远被阻塞。

数据库服务器中检测到一组事务中发生了死锁时，将选择一个牺牲者并放弃这个事务。作为牺牲者的事务会释放它所持有的资源，从而使其他事务继续进行。

当一组 Java 线程发生死锁时，这些线程永远不能再使用了，可能造成应用程序完全停止，或者某个特定的子系统停止，或者是性能降低。只有重启才能恢复。

#### 锁顺序死锁

两个线程试图以不同的顺序来获得相同的锁导致发生死锁。如果所有线程以固定的顺序来获得锁，那么在程序中就不会在出现锁顺序死锁问题。

```java
// 简单的锁顺序死锁（不要这么做）
public class LeftRightDeadLock {
    
    private final Object left = new Object();
    private final Object right = new Object();
    
    public void leftRight() {
        synchronized (left) {
            doSomething();
        }
    }
    
    public void rightLeft() {
        synchronized (right) {
            doSomething();
        }
    }
}
```

#### 动态的锁顺序死锁

锁的顺序取决于传递给方法的参数顺序。

```java
// 动态的锁顺序死锁（不要这么做）
public void transferMoney(Account fromAccount,
                          Account toAccount,
                          DollarAmount amount)
        throws InsufficientFundsException {
    synchronized (fromAccount) {
        synchronized (toAccount) {
            if (fromAccount.getBalance().compareTo(amount) < 0) {
                throw new InsufficientFundsException();
            } else {
                fromAccount.debit(amount);
                toAccount.credit(amount);
            }
        }
    }
}
```

通过锁顺序来避免死锁。

```java
private static final object tieLock = new Object();

public void transferMoney(final Account fromAcct,
                          final Account toAcct,
                          final DollarAmount amount)
        throws InsufficientFundsException {
    class Helper {
        public void transfer() throws InsufficientFundsException {
            if (fromAcct.getBalance().compareTo(amount) < 0) {
                throw new InsufficientFundsException();
            } else {
                fromAcct.debit(amount);
                toAcct.credit(amount());
            }
        }
    }
    int fromHash = System.identityHashCode(fromAcct);
    int toHash = System.identityHashCode(toAcct);
    
    if (fromHash < toHash) {
        synchronized (fromAcct) {
            synchronized (toAcct) {
                new Helper().transfer();
            }
        }
    } else if (fromHash > toHash) {
        synchronized (toAcct) {
            synchronized (fromAcct) {
                new Helper().transfer();
            }
        }
    } else {
        synchronized (tieLock) {
            synchronized (fromAcct) {
                synchronized (toAcct) {
                    new Helper().transfer();
                }
            }
        }
    }
}
```

tieLock 为 “加时赛” 锁。在极少数的情况下，两个对象可能拥有相同的散列值，此时在获得两个 Account 锁之前，需要首先获得这个 “加时赛” 锁，从而保证每次只有一个线程以为止的顺序获得这两个锁。

#### 在协作对象之间发生的死锁

如果在持有锁时调用某个外部方法，那么将出现活跃性问题。在这个外部方法中可能会获取其他锁（可能产生死锁），或者阻塞时间过长，导致其他线程无法及时获得当前被持有的锁。

#### 开放调用

开放调用是指在调用某个方法时不需要持有锁。分析一个完全依赖于开放调用的程序的活跃性，要比分析不依赖开放调用的程序的活跃性简单。

在使用开放调用时可能会失去原子性。

#### 资源死锁

- 当多个线程在相同的资源集合上等待时，导致发生死锁。
- 线程饥饿死锁。

### 死锁的避免与诊断

- 使用显示 Lock 类中的定时tryLock
- 通过线程转储信息来分析死锁

### 其他活跃性危险

- 饥饿。线程由于无法访问它所需要的资源而不能继续执行。
- 糟糕的响应性。
- 活锁。线程将不断重复执行相同的操作且总会失败。需要在重试机制中引入随机性来解决。