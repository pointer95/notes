# 自动内存管理机制

## Java 内存区域与内存溢出异常

### 运行时数据区域

#### 程序计数器

在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。

为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，即线程私有内存。

如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器值则为空（Undefined）。此内存是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。

#### Java 虚拟机栈

线程私有内存，生命周期与线程相同。

虚拟机栈描述的是 Java 方法执行的内存模型：每个方法在执行的同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应一个栈帧在虚拟机栈中从入栈道出栈的过程。

局部变量表存放了编译器可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用类型（reference）和 returnAddress 类型（指向了一条字节码指令的地址）。其中 64 位长度的 long 和 double 类型的数据会占用 2 个局部变量空间（Slot）。

局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。

异常情况：

- 线程请求的栈深度大于虚拟机所允许的深度，抛出 StackOveflowError 异常
- 虚拟机栈动态扩展时无法申请到足够的内存，抛出 OutOfMemoryError 异常

#### 本地方法栈

与虚拟机栈类似，执行虚拟机使用到的 Native 方法服务。

#### Java 堆

几乎所有的对象实例以及数组都在堆上分配。

Java 堆可以分为新生代和老年代，进一步分为 Eden 空间、From Survivor 空间、To Survivor 空间等。

Java 堆可以处于物理上不连续的内存空间中，只要逻辑上时连续的即可。

如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出 OutOfMemoryError 异常。

#### 方法区

与堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码等数据。

HotSpot 虚拟机使用永久代来实现方法区，JDK 7 把字符串常量池、静态变量等移出，JDK 8 完全废弃永久代。

JDK 8 以后被元空间代替。元空间存储类的元信息，位于本地内存中，字符串常量池、静态变量等位于堆中。

#### 运行时常量池

运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。

#### 直接内存

NIO 类中引入的一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。

### HotSpot 虚拟机对象探秘

#### 对象的创建

1. 检查 new 指令的参数是否能在常量池中定位到一个类的符号引用，并且在检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。
2. 为新生对象分配内存。对象所需的大小在类加载完成后便可完全确定。
3. 将分配到的内存空间都初始化为零值（不包括对象头）。
4. 对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。
5. 执行 init 方法，把对象按照程序猿的意愿进行初始化。

#### 对象的内存布局

对象在内存中存储的布局可以分为 3 块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。

对象头分为两部分：

- MarkWord

| 存储内容                  | 标志位 | 状态        |
|:---------------------:|:---:|:---------:|
| 对象哈希码、对象分代年龄          | 01  | 未锁定       |
| 指向锁记录的指针              | 00  | 轻量级锁定     |
| 指向重量级锁的指针             | 10  | 膨胀（重量级锁定） |
| 空                     | 11  | GC 标记     |
| 偏向线程 ID 、偏向时间戳、对象分代年龄 | 01  | 可偏向       |

- 类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。如果对象是一个 Java 数组，那在对象头中还必须有一块用于记录数组长度的数据。

实例数据是对象真正存储的有效信息。

对齐填充起着占位符的作用。

#### 对象的访问定位

- 句柄访问。Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。
- 直接指针访问。reference中存储的直接就是对象地址，对象实例数据中存储类型数据的指针。

使用句柄访问的好处是在对象被移动时只会改变句柄中的实例数据指针，reference 本身不需要改变；使用直接指针访问的好处是速度快，节省一次指针定位的时间开销。HotSpot 使用第二种方式。

### 实战：OutOfMemoryError 异常

#### Java 堆溢出

不断创建对象，并且保证 GC Roots 到对象之间有可达路径来避免垃圾回收机制清除这些对象。

通过参数 -XX:+HeapDumpOnOutOfMemoryError 可以让虚拟机在出现内存溢出时 Dump 出当前的内存堆转储快照。

```java
/**
 * VM Args: -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError
 */
public class HeapOOM {

    static class OOMObject {
    }

    public static void main(String[] args) {
        List<OOMObject> list = new ArrayList<OOMObject>();

        while (true) {
            list.add(new OOMObject());
        }
    }
}
```

#### 虚拟机栈和本地方法栈溢出

```java
/**
 * VM Args: -Xss128k
 */
public class JavaVMStackSOF {

    private int stackLength = 1;

    public void stackLeak() {
        stackLength++;
        stackLeak();
    }

    public static void main(String[] args) throws Throwable {
        JavaVMStackSOF sof = new JavaVMStackSOF();
        try {
            sof.stackLeak();
        } catch (Throwable e) {
            System.out.println("stack length:" + sof.stackLength);
            throw e;
        }
    }
}
```

#### 方法区和运行时常量池溢出

基本的思路是运行时产生大量的类去填满方法区。

```java
/**
 * VM Args: -XX:PermSIze=10M -XX:MaxPermSize=10M
 */
public class JavaMethodAreaOOM {

    public static void main(String[] args) {
        while (true) {
            Enhancer enhancer = new Enhancer();
            enhancer.setSuperclass(OOMObject.class);
            enhancer.setUserCache(false);
            enhancer.setCallback(new MethodInterceptor() {
                public Object intercept(Object obj,
                                        Method method,
                                        Object[] args,
                                        MethodProxy proxy) throws Throwable {
                    return proxy.invokeSuper(obj, args);
                }
            });
            enhancer.create();
        }
    }

    static class OOMObject {

    }
}
```

#### 本机直接内存溢出

```java
/**
 * VM Args: -Xmx20M -XX:MaxDirectMemorySize=10M
 */
public class DirectMemoryOOM {

    private static final int _1MB = 1024 * 1024;

    public static void main(String[] args) throws Exception {
        Field unsafeField = Unsafe.class.getDeclareFields()[0];
        unsafeField.setAccessible(true);
        Unsafe unsafe = (Unsafe) unsafeField.get(null);
        while (true) {
            unsafe.allocateMemory(_1MB);
        }
    }
}
```

由直接内存导致的内存溢出，一个明显的特征是在 Heap Dump 文件中不会看见明显的异常。

## 垃圾收集器与内存分配策略

### 对象已死吗

#### 引用计数算法

给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加 1；当引用失效时，计数器值就减 1；任何时刻计数器为 0 的对象就是不可能再被使用的。

实现简单，高效，但很难解决对象循环引用。

#### 可达性分析算法

通过一系列的称为 GC Roots 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的。

在 Java 语言中，可作为 GC Roots 的对象包括下面几种：

- 虚拟机栈中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中 JNI 引用的对象

#### 再谈引用

- 强引用。new 指令产生的对象，不会被垃圾回收。
- 软引用。描述一些还有用但并非必须的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。
- 弱引用。描述非必需对象，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。
- 虚引用。不会对对象的生存时间构成影响，也无法通过虚引用来取得一个对象实例。

#### 回收方法区

永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。

无用的类：

- 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例
- 加载该类的 ClassLoader 已经被回收
- 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

在大量使用反射、动态代理、CGLib 等 ByteCode 框架这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。

### 垃圾收集算法

#### 标记 - 清除算法

首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。

效率不高，会产生大量不连续的内存碎片。

#### 标记 - 复制算法

将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这块内存用完了，就将还存活的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。

实现简单，运行高效。但只能使用一半的内存，代价高昂。

将内存分为一块较大 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。当回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才用过的 Survivor 空间。当 Survivor 空间不够用时，需要依赖老年代进行分配担保。

#### 标记 - 整理算法

标记出所有需要回收的对象后，让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

#### 分代收集算法

在新生代使用复制算法，老年代使用标记 - 清理或者标记 - 整理算法。

### HotSpot 的算法实现

#### 枚举根节点

GC 进行时必须停顿所有 Java 执行进程，因为可达性分析过程中对象引用关系不能出现还在变化的情况。

HotSpot 使用一组 OopMap 的数据结构来记录引用位置。

#### 安全点

OopMap 在安全点记录了这些信息。即程序执行时只有在到达安全点时才能暂停。

- 抢先式中断。在 GC 发生时，首先把所有线程中断，如果发现有线程不在安全点上，就恢复线程，让它跑到安全点上。几乎不采用。
- 主动式中断。设置一个轮询标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，以及创建对象需要分配内存的地方。

#### 安全区域

没有分配 CPU 时间的线程，如 sleep 状态或 blocked 状态，将无法响应 JVM 的中断请求。

在线程执行到 Safe Region 中的代码时，首先标识自己已经进入了 Safe Region，当在 JVM 发起 GC 时，就不用管这些线程了。当线程要离开 Safe Region 时，要检查系统是否已经完成了根节点枚举或整个 GC 过程。

### 垃圾收集器

#### Serial 收集器

单线程的收集器。在进行垃圾收集时，必须暂停其他所有工作线程。

新生代采用复制算法，老年代采用标记 - 整理算法。

简单高效，对于单 CPU 环境来说，Serial 收集器没有线程交互的开销。

#### ParNew 收集器

Serial 收集器的的多线程版本。只有 Serail 和 ParNew 能与 CMS 收集器配合工作。

第一次实现了让垃圾收集线程与用户线程基本上同时工作。

#### Parallel Scavenge 收集器

新生代，复制算法，多线程的收集器。

为了达到一个可控制的吞吐量。高吞吐量可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合后台运算而不需要太多交互的任务。

GC 停顿时间缩短是以牺牲吞吐量和新生代空间换取的。

虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为 GC 自适应的调节策略。

#### Serial Old 收集器

Serial 收集器的老年代版本。

#### Parallel Old 收集器

Parallel Scavenge 收集器的老年代版本。

#### CMS 收集器

一种以获取最短回收停顿时间为目标的收集器。基于标记 - 清除算法实现。

运作过程：

- 初始标记

标记一下 GC Roots 能直接关联到的对象，速度很快。

- 并发标记

进行 GC Roots Tracing 的过程。

- 重新标记

为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。停顿时间比初始时间稍长，但比并发标记时间短。

- 并发清除

整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以从总体上来说，CMS 收集器的内存回收过程是与用户线程一起并发执行的。

优点：并发收集、低停顿

缺点：

- 降低吞吐量
- 无法处理浮动垃圾，可能出现 Concurrent Mode Failure 失败而导致另一次 Full GC 的产生
- 会产生大量空间碎片

#### G1 收集器

- 并行与并发
- 分代收集
- 空间整合

从整体上看是标记 - 整理算法，从局部上来看是复制算法。

- 可预测的停顿

能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。

G1 将整个 Java 堆划分为多个大小相等的独立区域，新生代和老年代不再是物理隔离，它们都是一部分 Region （不需要连续）的集合。

G1 能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个 Java 堆中进行全区域的垃圾收集。G1 跟踪各个 Region 里面的垃圾堆积的价值大小，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region 。

G1 中每个 Region 都有一个与之对应的 Remembered Set ，虚拟机使用 Remembered Set 来避免全堆扫描。

运作过程：

- 初始标记
- 并发标记
- 最终标记

为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程 Remembered Set 中，这阶段需要停顿线程，但是可并行执行。

- 筛选回收

首先对各个 Region 的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。这个阶段可以与用户程序一起并发执行，但是因为只回收一部分 Region ，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。

### 内存分配与回收策略

Minor GC ：指发生在新生代大的垃圾收集动作

Major GC / Full GC ：指发生在老年代的 GC

#### 对象优先在 Eden 分配

当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC 。

#### 大对象直接进入老年代

最典型的大对象是很长的字符串以及数组。

#### 长期存活的对象将进入老年代

如果对象在 Eden 出生并经过第一次 Minor GC 后仍然存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并且对象年龄设为 1 。对象在 Survivor 区中每经过一次 Minor GC ，年龄就增加 1 岁，当它的年龄增加到一定程度（默认 15 岁）就将会晋升到老年代中。

#### 动态对象年龄判定

如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。

#### 空间分配担保

在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。

如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。
