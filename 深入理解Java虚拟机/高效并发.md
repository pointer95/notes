# Java 内存模型与线程

## 硬件的效率与一致性

现代计算机系统需要加入一层读写速度尽可能接近处理器运算速度的高速缓存来作为内存与处理器之间的缓冲： 将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。

高速缓存引入了一个新的问题：缓存一致性。当多个处理器的运算任务都涉及同一块主内存区域是，将可能导致各自的缓存数据不一致。

为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致。

## Java 内存模型

### 主内存与工作内存

所有的变量都存储在主内存中

每条线程还有自己的工作内存，这些工作内存中保存了被该线程使用的变量的主内存副本拷贝，线程队变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。

### 内存间交互操作

访问操作：

- lock ：作用于主内存的变量，把一个变量标识为一条线程独占的状态。
- unlock ：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
- read：作用于主内存的变量，把一个变量的值从主内存传输到线程的工作内存中。
- load：作用于工作内存的变量，把 read 操作从主内存中得到的变量值放入工作内存的变量副本中。
- use：作用于工作内存的变量，把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。
- assign：作用于工作内存的变量，把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
- store：作用于工作内存的变量，把工作内存中一个变量的值传送到主内存中
- write：作用于主内存的变量，把 store 操作从工作内存中得到的变量的值放入主内存的变量中。

如果要把一个变量从主内存复制到工作内存中，那就要顺序地执行 read 和 load 操作，如果要把变量从工作内存同步回主内存，就要顺序执行 store 和 write 操作。

规则限定：

- 不允许 read 和 load 、store 和 write 操作之一单独出现。
- 循序一个线程丢弃它的最近的 assign 操作。
- 不允许一个线程无原因地把数据冲线程的工作内存同步回主内存。
- 一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化的变量。
- 一个变量在同一个时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一条线程重复执行多次。多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁。
- 如果对一个变量执行 lock 操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 load 或 assign 操作初始化变量的值。
- 如果一个变量事先没有被 lock 操作锁定，那就不允许对它执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定主的变量。
- 对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中。

### 对于 volatile 型变量的特殊规则

volatile 特性：

- 可见性

当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。

Java 里面的运算并非原子操作，导致 volatile 变量的运算在并发下一样是不安全的。

- 禁止指令重排序优化

### 原子性、可见性与有序性

- 原子性

由 Java 内存模型来直接保证的原子性变量操作包括 read 、load 、assign 、use 、store 和 write 。

虚拟机未把 lock 和 unlock 操作直接开放给用户使用，而是提供了更高层次的字节码指令 monitorenter 和 monitorexit 来隐式地使用这两个操作。

- 可见性

除了 volatile 之外，Java 还有两个关键字能实现可见性，即 synchronized 和 final 。

同步块的可见性是由“对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中” 这条规则获得的。

final 规则的可见性是指：被 final 修饰的字段在构造器中一旦完成初始化，并且构造器没有发生 this 引用逃逸，那在其他线程中就能看见 final 字段的值。

- 有序性

在本线程内观察，所有的操作都是有序的，指“线程内表现为串行的语义”；在一个线程中观察另一个线程，所有的操作都是无序的，指“指令重排序”现象和“工作内存与主内存同步延迟”现象。

Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性。

### 先行发生原则

- 程序次序规则：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。
- 管程锁定规则：一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。
- volatile 变量规则：对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。
- 线程启动规则：Thread 对象的 start() 方法先行发生于此线程的每一个动作。
- 线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测。
- 线程中断规则：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生。
- 对象终结规则：一个对象的初始化完成先行发生于它的 finalize() 方法的开始。
- 传递性：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那就可以得出操作 A 先行发生于操作 C 的结论。

## Java 与线程

### 线程的实现

- 使用内核线程实现
- 使用用户线程实现
- 使用用户线程加轻量级进程混合实现
- Java 线程的实现

### Java 线程调度

- 协同式线程调度
- 抢占式线程调度

### 状态转换

Java 语言定义了5种线程状态

- 新建（New）：创建后尚未启动的线程处于这种状态。

- 运行（Runnable）：Runnable 包括了操作系统线程状态中的 Running 和 Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着 CPU 为它分配执行时间。

- 无限期等待（Waiting）：处于这种状态的线程不会被分配 CPU 执行时间，它们要等待被其他线程显式地唤醒。以下方法会让线程陷入无限期的等待状态：

    - 没有设置 Timeout 参数的 Object.wait() 方法。

    - 没有设置 Timeout 参数的 Thread.join() 方法。
    - LockSupport.park() 方法。

- 限期等待（Timed Waiting）：处于这种状态的线程也不会被分配 CPU 执行时间，不过无限等待被其他线程显式地唤醒，在一定时间之后它们会由系统自动唤醒。以下方法会让线程陷入限期的等待状态：

    - Thread.sleep() 方法。
    - 设置了 TimeOut 参数的 Object.wait() 方法。
    - 设置了 TimeOut 参数的 Thread.join() 方法。
    - LockSupport.parkNanos() 方法。
    - LockSupport.parkUnit() 方法。

- 阻塞（Blocked）：线程被阻塞了，“阻塞状态”与“等待状态”的区别是：”阻塞状态“在等待着获取到一个排他锁，这个事件将在另外一个线程放弃这个锁的时候发生；”等待状态“则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。

- 结束（Terminated）：已终止线程的线程状态，线程已经结束执行。

# 线程安全与锁优化

## 线程安全

当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用对象的行为都可以获得正确的结果，那这个对象是线程安全的。

### Java 语言中的线程安全

#### 不可变

在 Java 语言中，不可变的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再采取任何的线程安全保障措施。

- final 关键字修饰的基本数据类型
- String 类
- 枚举类型
- Number 的部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但原子类 AtomicInteger 和 AtomicLong 则并非不可变的。

#### 绝对线程安全

如 Vector，但在多线程环境中，仍是不安全的

#### 相对线程安全

想对线程安全需要保证对这个对象单独的操作是线程安全的，我们在调用的时候不需要做额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。

在 Java 语言中，大部分的线程安全类都属于这种类型。

#### 线程兼容

线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用。

#### 线程对立

线程对立是指无论调用端是否采用了同步措施，都无法在多线程环境中并发使用的代码。

### 线程安全的实现方法

#### 互斥同步

- synchronized
- ReentrantLock
    - 等待可中断
    - 可设置为公平锁
    - 锁绑定多个条件

#### 非阻塞同步

- CAS

#### 无同步方案

- 可重入代码
- 线程本地存储

## 锁优化

### 自旋锁与自适应自旋

如果物理机器有一个以上的处理器，能让两个或两个以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一下”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待嘛，我们只需让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。

自旋等待不能代替阻塞，且不说对处理器数量的要求，自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的。因此自旋超过了限定的次数仍然没有成功获得锁，就应当用传统的方式去挂起线程了。

自适应意味着自旋的时间不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。

### 锁消除

锁消除是指对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。

锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，同步加锁自然无须进行。

### 锁粗化

如果一系列的连续操作都对同一个对象反复加锁和解锁，即使没有线程竞争，频繁的进行互斥同步操作也会导致不必要的星男损耗。

### 轻量级锁

轻量级锁在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。

### 偏向锁

偏向锁的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。



