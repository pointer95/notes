# 程序编译与代码优化

## 早期（编译期）优化

### 概述

Java 语言的编译期可能是指：

- 前端编译器把 *.java 文件转变成 *.class 文件的过程，包括 Sun 的 Javac、Eclipse JDT 中的增量式编译器（ECJ）。
- 虚拟机的后端运行期编译器（JIT 编译器）把字节码转变成机器码的过程，包括 HotSpot VM 的 C1、C2 编译器。
- 静态提前编译器（AOT 编译器）直接把 *.java 文件编译成本地机器代码的过程，包括 GNU Compiler for the Java（GCJ）、Excelsior JET。

### Javac 编译器

Javac 对代码的运行效率几乎没有任何优化措施，但做了许多针对 Java 语言编码过程的优化措施来改善程序猿的编码风格和提高编码效率，例如语法糖。

编译过程大致分为：

- 解析与填充符号表过程
- 插入式注解处理器的注解处理过程
- 分析与字节码生成过程

#### 解析与填充符号

1. 词法、语法分析

    词法分析将源代码的字符流转变为标记（Token）集合，单个字符是程序编写的最小元素，而标记则是编译过程的最小元素，关键字、变量名、字面量、字面量、运算符都可以成为标记。

    语法分析是根据 Token 序列构造抽象语法树的过程，抽象语法树（Abstract Syntax Tree，AST）是一种用来描述程序代码语法结构的树形表示方式，语法树的每一个节点都代表着程序代码中的一个语法结构，例如包、类型、修饰符、运算符、接口、返回值甚至代码注释等。

2. 填充符号表

    符号表是由一组符号地址和符号信息构成的表格。

    在语义分析中，符号表所登记的内容将用于语义检查和产生中间代码。在目标代码生成阶段，当对符号名进行地址分配时，符号表是地址分配的依据。

#### 注解处理器

插入式注解处理器的标准 API 在编译期间对注解进行处理，可以把它看做是一组编译器的插件。在这些插件里面，可以读取、修改、添加抽象语法树中的任意元素。如果这些插件在处理注解期间对语法树进行了修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有再对语法树进行修改为止，每一次循环称为一个 Round。

#### 语义分析与字节码生成

语义分析的主要任务是对结构上正确的源程序进行上下文有关性质的审查，如进行类型审查。

```java
int a = 1;
boolean b = false;
char c = 2;

int d = a + c;
int d = b + c;
char d = a + c;
```

上面 3 种赋值运算都能构成结构正确的语法树，但只有第 1 种的写法在语义上没有问题，能够通过编译。

1. 标注检查

    标注检查步骤检查的内容包括诸如变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配等。

    在该步骤中，有一个重要的动作称为常量折叠，例如：

    ```java
    int a = 1 + 2;
    ```

    在语法树上仍然能看到字面量 “1”、“2” 以及操作符 “+”，但是经过折叠后，它们将会被折叠为字面量 “3”。

2. 数据及控制流分析

    对程序上下文逻辑更进一步的验证，可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等问题。

    编译时期的数据及控制流分析与类加载时的数据及控制流分析的目的基本上是一致的，但校验范围有所区别，有一些校验项只有在编译期或运行期才能进行。例如：

    ```java
    public void foo(final int arg) {
        final int var = 0;
        // do something
    }
    
    public void foo(int arg) {
        int var = 0;
        // do something
    }
    ```

    这两段代码编译出来的 Class 文件没有任何区别，而局部变量与字段是有区别的，它在常量池中没有 CONSTANT_Fieldref_info 的符号引用，也就没有访问标志的信息，甚至可能连名称都不会保留下来，自然在 Class 文件中不可能知道一个局部变量是不是声明为 final 了。因此，将局部变量声明为 final，对运行期没有影响，变量的不变性仅由编译器在编译期间保障。

3. 解语法糖

    虚拟机运行时不支持语法糖，它们在编译阶段还原回简单的基础语法结构。

4. 字节码生成

    不仅把前面各个步骤所生成的信息转化成字节码写到磁盘中，还进行了少量的代码添加和转换工作。例如生成实例构造器 \<init>() 方法和类构造器 \<clinit>() 方法，把字符串的加操作替换为 StringBuffer 或 StringBuilder 的 append() 操作等。

### Java 语法糖

#### 泛型与类型擦除

Java 语言中的泛型只在程序源码中存在，在编译后的字节码文件中，就已经替换为原来的原生类型（Raw Type），并且在相应的地方插入了强制转型代码。因此，对于运行期的 Java 语言来说，ArrayList\<int> 与 ArrayList\<String> 就是同一个类。

```java
/**
 * 泛型擦除前的例子
 */
public static void main(String[] args) {
    Map<String, String> map = new HashMap<String, String>();
    map.put("hello", "你好");
    System.out.println(map.get("hello"));
}

/**
 * 泛型擦除后的例子
 */
public static void main(String[] args) {
    Map map = new HashMap();
    map.put("hello", "你好");
    System.out.println((String) map.get("hello"));
}
```

泛型擦除成相同的原生类型会导致无法重载。

#### 自动装箱、拆箱与遍历循环

```java
/**
 * 泛型、自动装箱和拆箱、遍历循环与变长参数
 */
public static void main(String[] args) {
    List<Integer> list = Arrays.asList(1, 2, 3, 4);
    int sum = 0;
    for (int i : list) {
        sum += i;
    }
    System.out.println(sum);
}

/**
 * 泛型、自动装箱和拆箱、遍历循环与变长参数编译之后
 */
public static void main(String[] args) {
    List list = Arrays.asList(new Integer[] {
        Integer.valueOf(1),
        Integer.valueOf(2),
        Integer.valueOf(3),
        Integer.valueOf(4),
    });
    int sum = 0;
    for (Iterator localIterator = list.iterator();
         localIterator.hasNext();) {
        int i = ((Integer)localIterator.next()).intValue();
        sum += i;
    }
    System.out.println(sum);
}
```

#### 条件编译

使用条件为常量的 if 语句进行条件编译。