# 程序编译与代码优化

## 早期（编译期）优化

### 概述

Java 语言的编译期可能是指：

- 前端编译器把 *.java 文件转变成 *.class 文件的过程，包括 Sun 的 Javac、Eclipse JDT 中的增量式编译器（ECJ）。
- 虚拟机的后端运行期编译器（JIT 编译器）把字节码转变成机器码的过程，包括 HotSpot VM 的 C1、C2 编译器。
- 静态提前编译器（AOT 编译器）直接把 *.java 文件编译成本地机器代码的过程，包括 GNU Compiler for the Java（GCJ）、Excelsior JET。

### Javac 编译器

Javac 对代码的运行效率几乎没有任何优化措施，但做了许多针对 Java 语言编码过程的优化措施来改善程序猿的编码风格和提高编码效率，例如语法糖。

编译过程大致分为：

- 解析与填充符号表过程
- 插入式注解处理器的注解处理过程
- 分析与字节码生成过程

#### 解析与填充符号

1. 词法、语法分析

    词法分析将源代码的字符流转变为标记（Token）集合，单个字符是程序编写的最小元素，而标记则是编译过程的最小元素，关键字、变量名、字面量、字面量、运算符都可以成为标记。

    语法分析是根据 Token 序列构造抽象语法树的过程，抽象语法树（Abstract Syntax Tree，AST）是一种用来描述程序代码语法结构的树形表示方式，语法树的每一个节点都代表着程序代码中的一个语法结构，例如包、类型、修饰符、运算符、接口、返回值甚至代码注释等。

2. 填充符号表

    符号表是由一组符号地址和符号信息构成的表格。

    在语义分析中，符号表所登记的内容将用于语义检查和产生中间代码。在目标代码生成阶段，当对符号名进行地址分配时，符号表是地址分配的依据。

#### 注解处理器

插入式注解处理器的标准 API 在编译期间对注解进行处理，可以把它看做是一组编译器的插件。在这些插件里面，可以读取、修改、添加抽象语法树中的任意元素。如果这些插件在处理注解期间对语法树进行了修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有再对语法树进行修改为止，每一次循环称为一个 Round。

#### 语义分析与字节码生成

语义分析的主要任务是对结构上正确的源程序进行上下文有关性质的审查，如进行类型审查。

```java
int a = 1;
boolean b = false;
char c = 2;

int d = a + c;
int d = b + c;
char d = a + c;
```

上面 3 种赋值运算都能构成结构正确的语法树，但只有第 1 种的写法在语义上没有问题，能够通过编译。

1. 标注检查

    标注检查步骤检查的内容包括诸如变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配等。

    在该步骤中，有一个重要的动作称为常量折叠，例如：

    ```java
    int a = 1 + 2;
    ```

    在语法树上仍然能看到字面量 “1”、“2” 以及操作符 “+”，但是经过折叠后，它们将会被折叠为字面量 “3”。

2. 数据及控制流分析

    对程序上下文逻辑更进一步的验证，可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等问题。

    编译时期的数据及控制流分析与类加载时的数据及控制流分析的目的基本上是一致的，但校验范围有所区别，有一些校验项只有在编译期或运行期才能进行。例如：

    ```java
    public void foo(final int arg) {
        final int var = 0;
        // do something
    }
    
    public void foo(int arg) {
        int var = 0;
        // do something
    }
    ```

    这两段代码编译出来的 Class 文件没有任何区别，而局部变量与字段是有区别的，它在常量池中没有 CONSTANT_Fieldref_info 的符号引用，也就没有访问标志的信息，甚至可能连名称都不会保留下来，自然在 Class 文件中不可能知道一个局部变量是不是声明为 final 了。因此，将局部变量声明为 final，对运行期没有影响，变量的不变性仅由编译器在编译期间保障。

3. 解语法糖

    虚拟机运行时不支持语法糖，它们在编译阶段还原回简单的基础语法结构。

4. 字节码生成

    不仅把前面各个步骤所生成的信息转化成字节码写到磁盘中，还进行了少量的代码添加和转换工作。例如生成实例构造器 \<init>() 方法和类构造器 \<clinit>() 方法，把字符串的加操作替换为 StringBuffer 或 StringBuilder 的 append() 操作等。

### Java 语法糖

#### 泛型与类型擦除

Java 语言中的泛型只在程序源码中存在，在编译后的字节码文件中，就已经替换为原来的原生类型（Raw Type），并且在相应的地方插入了强制转型代码。因此，对于运行期的 Java 语言来说，ArrayList\<int> 与 ArrayList\<String> 就是同一个类。

```java
/**
 * 泛型擦除前的例子
 */
public static void main(String[] args) {
    Map<String, String> map = new HashMap<String, String>();
    map.put("hello", "你好");
    System.out.println(map.get("hello"));
}

/**
 * 泛型擦除后的例子
 */
public static void main(String[] args) {
    Map map = new HashMap();
    map.put("hello", "你好");
    System.out.println((String) map.get("hello"));
}
```

泛型擦除成相同的原生类型会导致无法重载。

#### 自动装箱、拆箱与遍历循环

```java
/**
 * 泛型、自动装箱和拆箱、遍历循环与变长参数
 */
public static void main(String[] args) {
    List<Integer> list = Arrays.asList(1, 2, 3, 4);
    int sum = 0;
    for (int i : list) {
        sum += i;
    }
    System.out.println(sum);
}

/**
 * 泛型、自动装箱和拆箱、遍历循环与变长参数编译之后
 */
public static void main(String[] args) {
    List list = Arrays.asList(new Integer[] {
        Integer.valueOf(1),
        Integer.valueOf(2),
        Integer.valueOf(3),
        Integer.valueOf(4),
    });
    int sum = 0;
    for (Iterator localIterator = list.iterator();
         localIterator.hasNext();) {
        int i = ((Integer)localIterator.next()).intValue();
        sum += i;
    }
    System.out.println(sum);
}
```

#### 条件编译

使用条件为常量的 if 语句进行条件编译。

## 晚期（运行期）优化

### HotSpot 虚拟机内的即时编译器

- 为何 HotSpot 虚拟机要使用解释器与编译器并存的架构？
- 为何 HotSpot 虚拟机要实现两个不同的即时编译器？
- 程序何时使用解释器执行？何时使用编译器执行？
- 哪些程序代码会被编译为本地代码？如何编译为本地代码？
- 如何从外部观察即时编译器的编译过程和编译结果？

#### 解释器与编译器

当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即执行。在程序运行后，随着时间的推移，编译器把越来越多的代码编译成本地代码之后，可以获取更高的执行效率。当程序运行环境中内存资源限制较大，可以使用解释执行节约内存，反之可以使用编译执行来提升效率。

解释器还可以作为编译器激进优化时的一个 “逃生门”，让编译器根据概率选择一些大多数时候都能提升运行速度的优化手段，当激进优化的假设不成立，如加载了新类后类型继承结构出现了变化、出现 “罕见陷阱”（Uncommon Trap）时可以通过逆优化退回到解释状态继续执行。

HotSpot 虚拟机中内置了两个即时编译器，分别称为 Client Compiler 和 Server Compiler，或者简称为 C1 编译器和 C2 编译器。

由于即时编译器编译本地代码需要占用程序运行时间，要编译出优化程度更高的代码，所花费的时间可能更长；而且想要编译出优化程度更高的代码，解释器可能还要替编译器收集性能监控信息，这对解释执行的速度也有影响。为了在程序启动响应速度与运行效率之间达到平衡，HotSpot 虚拟机还会逐渐启用分层策略（Tiered Compilation）的策略。

- 第 0 层，程序解释执行，解释器不开启性能监控功能（Profiling），可触发第 1 层编译。
- 第 1 层，也称为 C1 编译，将字节码编译为本地代码，进行简单、可靠的优化，如有必要将加入性能监控的逻辑。
- 第 2 层（或 2 层以上），也称为 C2 编译，也是将字节码编译为本地代码，但是会启用一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化。

实施分层编译后，C1 和 C2编译器将会同时工作，许多代码都可能会被多次编译，用 C1 获取更高的编译速度，用 C2 来获取更好的编译质量，在解释执行的时候也无须在承担收集性能监控信息的任务。

#### 编译对象与触发条件

在运行过程中会被即时编译器编译的热点代码有两类：

- 被多次调用的方法
- 被多次执行的循环体

对于第二种情况，虽然编译动作是由循环体触发，但编译器依然会以整个方法作为编译对象。这种编译方式因为编译发生在方法执行过程之中，因此形象地称之为栈上替换（On Stack Replacement），即方法栈帧还在栈上，方法就被替换了。

判断一段代码是不是热点代码，是不是需要触发即时编译，这样的行为称为热点探测。主要的方式有两种：

- 基于采样的热点探测（Sample Based Hot Spot Detection）：虚拟机会周期性地检查各个线程的栈顶，如果发现某个或某些方法经常出现在栈顶，那这个方法就是热点方法。这种方式的好处是实现简单、高效，还可以很容易地获取方法调用关系，缺点是很难精确地确认一个方法的热度，容易因为收到线程阻塞或别的外界因素的影响而扰乱热点探测。
- 基于计数器的热点探测（Counter Based Hot Spot Detection）：虚拟机会为每个方法（甚至是代码块）建立计数器，统计方法的执行次数，如果执行次数超过一定的阈值就认为它是热点方法。这种方式实现比较麻烦，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系，但是统计结果相对更加精确和严谨。

HotSpot 虚拟机使用的是第二种方式，它为每个方法准备了两类计数器：方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）。在确定虚拟机运行参数的前提下，这两个计数器都有一个确定的阈值，当计数器超过阈值溢出了，就会触发 JIT 编译。

- 方法调用计数器

    用于统计方法被调用的次数，它的默认阈值在 Client 模式下是 1500 次，在 Server 模式下是 10 000 次，这个阈值可以通过虚拟机参数 -XX: CompileThreshold 来人为设定。当一个方法被调用时，会先检查该方法是否被 JIT 编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加 1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阈值。如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。

    如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行效率，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减，而这段时间就称为此方法统计的半衰周期。进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的。

- 回边计数器

    用于统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为回边。建立回边计数器统计的目的就是为了触发 OSR 编译。

    - 虚拟机运行在 Client 模式下回边计数器阈值计算公式为：

        方法调用计数器阈值（Compile Threshold） * OSR 比率（OnStackReplacePercentage） / 100

    - 虚拟机运行在 Server 模式下回边计数器阈值计算公式为：

        方法调用计数器阈值（Compile Threshold） *  (OSR 比率（OnStackReplacePercentage）- 解释器监控比率（IntepreterProfilePercentage）) / 100

当解释器遇到一条回边指令时，会先查找将要执行的代码片段是否有已经编译好的版本，如果有，它将会优先执行已编译的代码，否则就把回边计数器的值加 1，然后判断方法调用计数器与回边计数器值之和是否超过回边计数器的阈值。当超过阈值的时候，将会提交一个 OSR 编译请求，并且把回边计数器的值降低一些，以便继续在解释器中执行循环，等待编译器输出编译结果。

#### 编译过程

在默认设置下，虚拟机在代码编译器还未完成之前，都仍然将按照解释方式继续执行，而编译动作则在后台的编译线程中进行。在禁止后台编译后，一旦达到 JIT 的编译条件，执行线程向虚拟机提交编译请求后将会一直等待，直到编译过程完成后再开始执行编译器输出的本地代码。

对于 Client Compiler 来说，它是一个简单快速的三段式编译器，主要的关注点在于局部性的优化，而放弃了许多耗时较长的全局优化手段。

在第一个阶段，一个平台独立的前端将字节码构造成一种高级中间代码表示（High-Level Intermediate Representaion，HIR）。HIR 使用静态单分配（Static Single Assignment，SSA）的形式来代表代码值，这可以使得一些在 HIR 的构造过程之中和之后进行的优化动作更容易实现。在此之前编译器会在字节码上完成一部分基础优化，如方法内联、常量传播等优化将会在字节码被构造成 HIR 之前完成。

在第二个阶段，一个平台相关的后端从 HIR 中产生低级中间代码表示（Low-Level Intermediate Representaion，LIR），而在此之前会在 HIR 上完成另外一些优化，如空值检查消除、范围检查消除等，以便让 HIR 达到更高效的代码表示形式。

最后阶段是在平台相关的后端使用线性扫描算法在 LIR 上分配寄存器，并在 LIR 上做窥孔优化，然后产生机器代码。

而 Server Compiler 则是专门面向服务端的典型应用并为服务端的性能配置特别调整过的编译器，也是一个充分优化过的高级编译器，几乎能达到 GNU C++ 编译器使用 -O2 参数时的优化强度，它会执行所有经典的优化动作，如无用代码消除、循环展开、循环表达式外提、消除公共子表达式、常量传播、基本块重排序等，还会实施一些与 Java 语言特性密切相关的优化技术，如范围检查消除、空值检查消除等。另外，还可能根据解释器或 Client Compiler 提供的性能监控信息，进行一些不稳定的激进优化，如守护内联、分支频率预测等。