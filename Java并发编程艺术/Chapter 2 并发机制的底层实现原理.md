## 并发机制的底层实现原理

### volatile 的应用

volatile 是轻量级的 synchronized ，在多处理器开发中保证了共享变量的 “可变性”，即当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。

volatile 比 synchronized 的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。

#### volatile 的定义与实现原理

如果一个字段被声明成 volatile ，Java线程模型确保所有线程看到这个变量的值是一致的。

实现原则：

-  Lock 前缀指令会引起处理器缓存回写到内存
- 一个处理器的缓存回写到内存会导致其他处理器的缓存无效

#### volatile 的使用优化

LinkedTransferQueue 在使用 volatile 变量时，用一种追加字节的方式来优化队列出队和入队的性能。

```java
/** 队列中的头部节点 */
private transient final PaddedAtomicReference<QNode> head;
/** 队列中的尾部节点 */
private transient final PaddedAtomicReference<QNode> tail;
static final class PaddedAtomicReference <T> extends AtomicReference <T> {
    // 使用很多4个字节的引用追加到64个字节
    Object p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, pa, pb, pc, pd, pe;
    PaddedAtomicReference(T r) {
        super(r);
    }
}
public class AtomicReference <V> implements java.io.Serializable {
    private volatile V value;
    // ...
}
```

内部类 PaddedAtomicReference 将共享变量追加到 64 字节。

由于部分处理器的 L1、L2 或 L3 缓存的高速缓存行是 64 个字节，不支持部分填充缓存行。如果队列的头节点和尾节点都不足 64 字节，处理器会将它们都读到同一个高速缓存行中，在多处理器下每个处理器都会缓存同样的头节点、尾节点，当一个处理器试图修改头节点时，会将整个缓存行锁定，那么在缓存一致性机制的作用下，会导致其他处理器不能访问自己高速缓存中的尾节点，从而将严重影响到队列的入队和出队效率。

不是所有情况下都追加到 64 字节：

- 缓存行非 64 字节的处理器
- 共享变量不会频繁地写

### synchronized 的实现原理与应用

java 中的每一个对象都可以作为锁：

- 对于普通同步方法，锁是当前实例对象
- 对于静态同步方法，锁是当前类的 Class 对象
- 对于同步方法块，锁是 Synchronized 括号里配置的对象

#### Java 对象头

synchronized 用的锁是存在 Java 对象头里的，如果对象是数组类型，则虚拟机用 3 个字宽（ Word ）存储对象头，如果对象是非数组类型，则用 2 个字宽存储对象头。

在 32 位虚拟机中，1 字宽等于 4 字节，即 32 bit；在 64 位虚拟机中，则是 64 bit 。

#### 锁的升级与对比

锁一共有 4 种状态，分别为：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级，但是不能降级，目的是为了提高获得锁和释放锁的效率。

- 偏向锁

在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。

- 轻量级锁

### 原子操作的实现原理

#### 处理器如何实现原子操作

- 总线锁

使用处理器提供的一个 LOCK # 信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞，那么该处理器可以独占共享内存。由于其他处理器的请求被阻塞，所以总线锁的开销比较大。

- 缓存锁

内存区域如果被缓存在处理器的缓存行中，并且在 Lock 操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言 LOCK # 信号，而是修改内部的内存地址，并允许它的缓存一执行机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据。

有两种情况下处理器不会使用缓存行：

- 当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行时，则处理器会调用总线锁定
- 有些处理器不支持缓存锁定

#### Java 如何实现原子操作

- 自旋 CAS 实现原子操作

- 锁机制实现原子操作

CAS实现原子操作的三大问题：

- ABA 问题
- 循环时间长开销大
- 只能保证一个共享变量的原子操作，可以用 AtomicReference 类来保证引用对象之间的原子性