## Java 内存模型

### Java 内存模型的基础

#### 并发编程模型的两个关键问题

- 线程之间如何通信
- 线程之间如何同步

通信是指线程之间以何种机制来交换信息。在命令式编程中，通信机制有两种：共享内存和消息传递。

同步是指程序中用于控制不同线程间操作发生的相对顺序的机制。

#### Java 内存模型的抽象结构

线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，其中存储了该线程以读 / 写共享变量的副本。

如果线程 A 与线程 B 之间要通信的话，必须要经历 2 个步骤：

- 线程 A 把本地内存 A 中更新过的共享变量刷新到主内存中去。
- 线程 B 到主内存中去读线程 A 之前已更新过的共享变量。

#### 从源代码到指令序列的重排序

为了提高性能，编译器和处理器常常会对指令做重排序。重排序分 3 种类型：

- 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
- 指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变对应机器指令的执行顺序。
- 内存系统的重排序。由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是乱序执行。

从 Java 源代码到最终实际执行的指令序列，会分别经历编译器优化的重排序、指令级并行的重排序和内存系统的重排序。这些重排序可能会导致多线程程序出现内存可见性问题。

对于编译器，JMM 的编译器重排序规则会禁止特定类型的编译器重排序。对于处理器重排序，JMM 的处理器重排序规则会要求 Java 编译器在生成指令序列时，插入特定类型的内存屏障指令，通过内存屏障指令来禁止特定类型的重排序。

#### happens-before 简介

无论是在一个线程之内还是不同线程之间，如果一个操作执行的结构需要对另一个操作可见，那么这两个操作之间必须要存在 happens-before 关系。

- 程序顺序规则：一个线程中的每个操作，happens-before 于该线程中的任意后续操作
- 监视器锁规则：对于一个锁的解锁，happens-before 于随后对这个锁的加锁
- volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读
- 传递性：如果 A happens-before B，且 B happens-before C ，那么 A happens-before C

一个 happens-before 规则对应一个或多个编译器和处理器重排序规则。它避免为了理解 JMM 提供的内存可见性保证而去学习复杂的重排序规则以及这些规则的具体实现方法。

### 重排序

