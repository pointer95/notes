## 死锁

### 资源

需要排他性使用的对象称为资源（resource）。

#### 可抢占资源和不可抢占资源

可抢占资源可以从拥有他的进程中抢占而不会产生任何副作用。不可抢占资源是指在不引起相关的计算失败的情况下，无法把它从占有它的进程处抢占过来。

#### 资源获取

资源获取可能会导致死锁。

### 死锁简介

> 如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件，那么，该进程集合是死锁的。

#### 资源死锁的条件

- 互斥条件。每个资源要么已经分配给了一个进程，要么就是可用的。
- 占有和等待条件。已经得到了某个资源的进程可以再请求新的资源。
- 不可抢占条件。已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。
- 环路等待条件。死锁发生时，系统中一定有由两个或两个以上的进程组成的一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。

#### 处理死锁的策略

- 忽略该问题
- 检测死锁并恢复
- 仔细对资源进行分配，动态地避免死锁
- 通过破坏引起死锁的四个必要条件之一，防止死锁的产生

### 鸵鸟算法

假装根本没有问题发生。每个人对该方法的看法都不相同，数学家认为不论代价多大，都要彻底防止死锁的发生；工程师想要了解死锁发生的频度、系统因各种原因崩溃的次数及死锁的重要性。

### 死锁检测和死锁恢复

#### 每种类型一个资源的死锁检测

建立有向图，依次将每一个节点作为一棵树的根节点，并进行深度优先搜索。如果碰到已经遇到过的节点，那么就算找到一个环。如果从任何给定的节点出发的弧都被穷举了，那么就回溯到前面的节点。如果回溯到根并且不能再深入下去，那么从当前节点出发的子图就不包含任何环。如果所有的节点都是如此，那么整个图就不存在环，即系统不存在死锁。

#### 每种类型多个资源的死锁检测

### 从死锁中恢复

1. 利用抢占恢复

    在某些情况下，可能会临时将某个资源从它的当前所有者那里转移给另一个进程。

2. 利用回滚恢复

    设置检查点（checkpoint），当发生死锁时回滚到上一个检查点。

3. 通过杀死进程恢复

### 死锁避免

**银行家算法**用来判断对请求的满足是否会导致进入不安全状态，如果是，就拒绝请求。

不安全状态并不是死锁，系统在不安全状态下仍能运行一段时间。安全状态和不安全状态的区别是：从安全状态出发，系统能够保证所有进程都能完成，而从不安全状态出发，就没有这样保证。

#### 死锁预防

1. 破坏互斥条件
2. 破坏占有和等待条件
3. 破坏不可抢占条件
4. 破坏环路等待条件

### 其他问题

- 两阶段加锁

- 通信死锁

- 活锁

- 饥饿