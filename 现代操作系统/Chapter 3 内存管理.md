## 内存管理

**分层存储器体系**：高速缓存、内存、硬盘。

**存储管理器**：有效地管理内存，即记录内存的使用与剩余和分配释放内存。

### 无存储器抽象

程序直接访问物理内存。

问题：

1. 如果用户程序可以寻址内存的每个字节，它们就可以很容易地破坏操作系统。
2. 使用这种模型同时运行多个程序难以实现。

操作系统把当前内存中所有内存保存到磁盘文件中，然后把下一个程序读人到内存中再运行即可。只要在某一个时间内存中只有一个程序，那么就不会发生冲突。

### 一种存储器抽象：地址空间

#### 地址空间的概念

地址空间为程序创造了一种抽象的内存，是一个进程用于寻址内存的一套地址集合。

使用基址寄存器和界限寄存器，程序装载到内存中连续的空闲位置且装载期间无须重定位。当一个程序运行时，程序的其实物理地址装载到基址寄存器中，程序的长度装载到界限寄存器中。每次一个进程访问内存，取一条指令，读或写一个数据字，CPU 硬件会在把地址发送到内存总线前，自动把基址值加到进程发出的地址值上。同时，它检查程序提供的地址是否等于或大于界限寄存器的值，如果访问的地址超过了界限，会产生错误并中止访问。

在很多实际系统中，只有操作系统才能修改基址寄存器和界限寄存器。

使用基址寄存器和界限寄存器重定位的缺点是：每次访问内存都需要进行加法和比较运算。比较运算可以做得很快，但是加法运算由于进位传递时间的问题，在没有使用特殊电路的情况下会显得很慢。

#### 交换技术

处理内存超载的通用方法：

- 交换技术

- 虚拟内存

交换技术是把一个进程完整调入内存，使该进程运行一段时间，然后把它存回磁盘。

交换在内存中产生了多个空闲区，通过把所有的进程尽可能向下移动，有可能将这些小的空闲区合成一大块，该技术称为内存紧缩。通常不会进行这个操作，因为会耗费大量的 CPU 时间。

如果进程的数据段可以增长，当换入或移动进程时为它分配一些额外的内存。

#### 空闲内存管理

1. 使用位图的存储管理

    每个分配单元对应于位图的一位，0 表示空闲，1 表示占用。分配单元越小，位图越大。

2. 使用链表的存储管理

    维护一个记录已分配内存段和空闲内存段的链表。链表中的每一个结点都包含空闲区或进程的指示标志，起始地址、长度和指向下一个结点的指针。

为创建的进程分配内存的算法：

- 首次适配算法。存储管理器沿着段链表进行搜索，直到找到一个足够大的空闲区。
- 下次适配算法。每次找到合适的空闲区时都记录当时的位置，以便在下次寻找空闲区时从上次结束的地方开始搜索。
- 最佳适配算法。搜索整个链表，找出能够容纳进程的最小的空闲区，但会产生大量无用的小空闲区。
- 最差适配算法。搜索整个链表，分配最大的可用空闲区。
- 快速适配算法。为按大小排序后的空闲区维护单独的链表，链表的结点是指向空闲区的指针。

### 虚拟内存

每个程序拥有自己的地址空间，这个空间被分割成多个块，每一块称作一页或页面（Page）。每一页有连续的地址范围。这些页其中一部分被映射到物理内存。当程序引用到一部分在物理内存中的地址空间时，由硬件立刻执行必要的映射。当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的指令。

虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中。当一个程序等待它的一部分读如内存时，可以把 CPU 交给另一个进程使用。

#### 分页

由程序产生的地址称为虚拟地址，它们构成了一个虚拟地址空间。在没有虚拟内存的计算机上，系统直接将虚拟内存地址送到内存总线上，读写操作使用具有相同地址的物理内存字；而在使用虚拟内存的情况下，虚拟地址被送到内存管理单元（Memory Management Unit，MMU），MMU 把虚拟地址映射为物理内存地址。

在物理内存中按照固定大小划分的若干单元称为页框。页面和页框的大小通常是一样的。RAM 和磁盘之间的交换总是以整个页面为单元进行的。

如果 MMU 注意到某个页面没有被映射，于是使 CPU  陷入到操作系统中，这个陷阱称为缺页中断或缺页错误。操作系统找到一个很少使用的页框且把它的内容写入磁盘。随后把需要访问的页面读到刚才回收的页框中，修改映射关系，然后重新启动引起陷阱的指令。

#### 页表

页表的目的是把虚拟页面映射为页框。

虚拟地址可以被分成虚拟页号和偏移量。虚拟页号可用作页表的索引，以找到该虚拟页面的对应的页表项。有页表项可以找到页框号。然后把页框号拼接到偏移量的高位端，以替换掉虚拟页号，形成送往内存的物理地址。

#### 页表项的结构

- 页框号
- 在 / 不在位。该位为 1 时表示该表项是有效的，为 0 时表示该表项对应的虚拟页面现在不在内存中，访问该页面会引起一个页面中断。
- 保护位。该位指出一个页允许什么类型的访问。最简单的形式是这个域只有一位，0 表示读/写，1 表示只读。更先进的方法是使用三位，各位分别对应是否启用读、写、执行该页面。
- 修改位和访问位。用来记录页面的使用状况。在写入一页时由硬件自动设置修改位，如果一个页面已经被修改过，则必须把它写回磁盘；如果一个页面没有被修改过，则只简单地把它丢弃就行可以，因为它在磁盘上的副本仍然是有效的。访问位的值被用来帮助操作系统在发生缺页中断时选择要被淘汰的页面。
- 高速缓存禁止位。假如操作系统正在紧张地循环等待某个 I/O 设备对它刚发出的命令作出响应，保证硬件是不断地从设备中读取数据而不是访问一个旧的被高速缓存的副本。

#### 加速分页过程

在任何分页系统中，都需要考虑两个问题：

1. 虚拟地址到物理地址的映射必须非常快
2. 如果虚拟地址空间很大，页表也会很大

- 转换检测缓冲区（TLB）

在大多数程序总是对少量的页面进行多次访问的前提下，为计算机设置一个小型的硬件设备，将虚拟地址直接映射到物理地址，而不必再访问页表。这种方法有时被称为相联存储器或快表。

将一个虚拟地址放入 MMU 中进行转换时，硬件首先通过将该虚拟页号与 TLB 中所有表项同时进行匹配。如果发现了一个有效的匹配并且要进行的访问操作并不违反保护位，则将页框号直接从 TLB 中取出而不必再访问页表。如果虚拟页号确实是在 TLB 中，但指令试图在一个只读页面上进行写操作，则会产生一个保护错误。如果 MMU  检测到没有有效的匹配项，就会进行正常的页表查询。接着从 TLB 中淘汰一个表项，用新找到的页表项代替它。

- 软件 TLB 管理

用软件搜索页表时的问题是，页表可能不在 TLB 中，这就会导致处理过程中的额外的 TLB 失效。可以通过在内存中的固定位置维护一个大的（如 4KB）TLB 表项的软件高速缓存（该高速缓存的页面一直保存在 TLB 中）来减少TLB 失效。通过首先检查软件高速缓存，操作系统能够实质性地减少 TLB 失效。

软失效：页面在内存中

硬失效：页面在磁盘中，处理时间是软失效的百万倍

#### 针对大内存的页表

1. 多级页表

    为了避免把全部页表一直保存在内存中。在顶级页表中未使用的表项不会有二级页表。

2. 倒排页表

    实际内存中每一个页框对应一个表项，而不是每个虚拟页面对应一个表象。但会导致从虚拟地址到物理地址的转换变得困难。每次访问虚拟页面都必须搜索整个倒排页表来查找某一个表项。因此需要实现一个散列表。

### 页面置换算法

#### 最优页面置换算法

在缺页中断发生时，有些页面在内存中，其中有一个页面将很快被访问，其他页面则可能要到10、100 或 1000 条指令后才会被访问，每个页面都可以用在该页面首次被访问前所要执行的指令数作为标记。最优页面置换算法规定应该置换标记最大的页面。

当缺页中断发生时，操作系统无法知道各个页面下一次将在什么时候被访问。因此该算法无法实现。

#### 最近未使用页面置换算法

设置两个状态位，当页面被访问时设置 R 位，当页面被写入时设置 M 位。

当发生缺页中断时，操作系统检查所有的野蛮并根据它们当前的 R 位和 M 位的值，把它们分为 4 类：

- 第 0 类：没有被访问，没有被修改
- 第 1 类：没有被访问，已被修改
- 第 2 类：已被访问，没有被修改
- 第 3 类：已被访问，已被修改

第 3 类清除 R 位不清除 M 位将产生第 1 类。

NRU 算法随机从类编号最小的非空类中挑选一个页面淘汰。

#### 先进先出页面置换算法

由操作系统维护一个所有当前在内存中的页面的链表，最新进入的页面放在表尾，最早进入的页面放在表头。当发生缺页中断时，淘汰表头的页面并把新调入的页面加到表尾。

#### 第二次机会页面置换算法

对 FIFO 算法进行改进，检查最老页面的 R 位，如果是 0，那么可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端。

#### 时钟页面置换算法

将所有页面保存在一个环形链表里，这样不需要在链表中移动页面，只移动指向最老页面的指针就可以。

#### 最近最少使用页面置换算法

在缺页中断发生时，置换未使用时间最长的页面。

#### 用软件模拟 LRU

NFU 算法将每个页面与一个软件计数器相关联，计数器的初值为 0。每次时钟中断时，有操作系统扫描内存中所有的页面，将每个页面的 R 位（它的值是 0 或 1）加到它的计数器上。发生缺页中断时，则置换计数器值最小的页面。

NFU 算法的主要问题是从来不忘记任何事情，如果第一次扫描的执行时间桥好事各次扫描中最长的，含有以后各次扫描代码的页面的计数器可能总是比第一次扫面代码的页面的计数器小，结果是操作系统将置换有用的页面。

老化算法：首先，在 R 位被加进之前先讲计数器右移一位，其次，将 R 位加到计数器最左端的位而不是最右端的位。