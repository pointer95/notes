## 内存管理

**分层存储器体系**：高速缓存、内存、硬盘。

**存储管理器**：有效地管理内存，即记录内存的使用与剩余和分配释放内存。

### 无存储器抽象

程序直接访问物理内存。

问题：

1. 如果用户程序可以寻址内存的每个字节，它们就可以很容易地破坏操作系统。
2. 使用这种模型同时运行多个程序难以实现。

操作系统把当前内存中所有内存保存到磁盘文件中，然后把下一个程序读人到内存中再运行即可。只要在某一个时间内存中只有一个程序，那么就不会发生冲突。

### 一种存储器抽象：地址空间

#### 地址空间的概念

地址空间为程序创造了一种抽象的内存，是一个进程用于寻址内存的一套地址集合。

使用基址寄存器和界限寄存器，程序装载到内存中连续的空闲位置且装载期间无须重定位。当一个程序运行时，程序的其实物理地址装载到基址寄存器中，程序的长度装载到界限寄存器中。每次一个进程访问内存，取一条指令，读或写一个数据字，CPU 硬件会在把地址发送到内存总线前，自动把基址值加到进程发出的地址值上。同时，它检查程序提供的地址是否等于或大于界限寄存器的值，如果访问的地址超过了界限，会产生错误并中止访问。

在很多实际系统中，只有操作系统才能修改基址寄存器和界限寄存器。

使用基址寄存器和界限寄存器重定位的缺点是：每次访问内存都需要进行加法和比较运算。比较运算可以做得很快，但是加法运算由于进位传递时间的问题，在没有使用特殊电路的情况下会显得很慢。

#### 交换技术

处理内存超载的通用方法：

- 交换技术

- 虚拟内存

交换技术是把一个进程完整调入内存，使该进程运行一段时间，然后把它存回磁盘。

交换在内存中产生了多个空闲区，通过把所有的进程尽可能向下移动，有可能将这些小的空闲区合成一大块，该技术称为内存紧缩。通常不会进行这个操作，因为会耗费大量的 CPU 时间。

如果进程的数据段可以增长，当换入或移动进程时为它分配一些额外的内存。

#### 空闲内存管理

1. 使用位图的存储管理

    每个分配单元对应于位图的一位，0 表示空闲，1 表示占用。分配单元越小，位图越大。

2. 使用链表的存储管理

    维护一个记录已分配内存段和空闲内存段的链表。链表中的每一个结点都包含空闲区或进程的指示标志，起始地址、长度和指向下一个结点的指针。

为创建的进程分配内存的算法：

- 首次适配算法。存储管理器沿着段链表进行搜索，直到找到一个足够大的空闲区。
- 下次适配算法。每次找到合适的空闲区时都记录当时的位置，以便在下次寻找空闲区时从上次结束的地方开始搜索。
- 最佳适配算法。搜索整个链表，找出能够容纳进程的最小的空闲区，但会产生大量无用的小空闲区。
- 最差适配算法。搜索整个链表，分配最大的可用空闲区。
- 快速适配算法。为按大小排序后的空闲区维护单独的链表，链表的结点是指向空闲区的指针。