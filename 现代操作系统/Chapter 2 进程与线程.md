## 进程与线程

### 进程

进程是对正在运行程序的一个抽象。

#### 进程模型

在进程模型中，计算机上所有可运行的软件，通常也包括操作系统，被组织成若干顺序进程，简称进程。

一个进程是某种类型的一个活动，它有程序、输入、输出以及状态。单个处理器可以被若干进程共享，它使用某种调度算法决定何时停止一个进程的工作，并转而为另一个进程提供服务。

#### 进程的创建

四种主要事件会导致进程的创建：

- 系统初始化
- 正在运行的程序执行了创建进程的系统调用
- 用户请求创建一个新进程
- 一个批处理作业的初始化

新进程都是由于一个已存在的进程执行了一个用于创建进程的系统调用而创建的。

在 UNIX 系统中，只有一个系统调用可以用来创建新进程：fork 。这个系统调用会创建一个与调用进程相同的副本。在调用了 fork 后，这两个进程拥有相同的内存映像、同样的环境字符串和同样的打开文件。通常，子进程接着执行 execve 或一个类似的系统调用，以修改其内存映像并运行一个新的程序。

#### 进程的终止

进程的终止通常由下列条件引起：

- 正常退出
- 出错退出
- 严重错误
- 被其他进程杀死

#### 进程的层次结构

进程只有一个父进程，子进程可以创建更多的进程，组成一个进程的层次结构。

在 UNIX 中，进程和它的所有子进程以及后裔共同组成一个进程组。当用户从键盘发出一个信号时，该信号被送给当前与键盘相关的进程组中的所有成员。每个进程可以分别捕获该信号、忽略该信号或采取默认的动作，即被该信号杀死。

#### 进程的状态

- 运行态（该时刻进程实际占用 CPU ）
- 就绪态（可运行，但因为其他进程正在运行而暂时停止）
- 阻塞态（除非某种外部事件发生，否则进程不能运行）

#### 进程的实现

操作系统维护着一个结构数组，即进程表。每个进程占用一个进程表项。该表项包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状况、所打开文件的状态、账号和调度信息，以及其他在进程由运行态转换到就绪态或阻塞态时必须保存的信息。

### 线程

#### 线程的使用

使用线程的原因：

- 通过将应用程序分解成可以准并行运行的多个顺序线程，简化程序设计模型
- 线程比进程更轻量级
- 如果存在大量的计算和大量的 I/O 处理，拥有多个线程允许这些活动彼此重叠进行，从而加快应用程序执行的速度
- 在多 CPU 系统中，真正的并行有了实现的可能

#### 经典的线程模型

- 程序计数器，用来记录接着要执行哪一条指令
- 寄存器，用来保存线程当前的工作变量
- 堆栈，用来记录执行历史，其中每一帧保存了一个已调用的但是还没有从中返回的过程

进程中的所有线程都有完全一样的地址空间，即共享同样的全局变量。这些线程之间是不安全的，各个线程都可以访问进程地址空间中的每一个内存地址，因此一个线程可以读、写或甚至清除另一个线程的堆栈。

#### POSIX 线程

| 线程调用             | 描述                         |
| :------------------- | :--------------------------- |
| pthread_create       | 创建一个线程                 |
| pthread_exit         | 结束调用的线程               |
| pthread_join         | 等待一个特定的线程退出       |
| pthread_yield        | 释放 CPU 来运行另外一个线程  |
| pthread_attr_init    | 创建并初始化一个线程属性结构 |
| pthread_attr_destroy | 删除一个线程的属性结构       |

#### 在用户空间中实现线程

优点：

- 用户级线程包可以在不支持线程的操作系统上实现
- 允许每个进程有自己定制的调度算法

问题：

- 如何实现阻塞系统调用
- 如何一个线程开始运行，那么在该进程中的其他线程就不能运行，除非第一个线程自动放弃 CPU

#### 在内核中实现线程

当一个线程阻塞时，内核可以根据选择运行另一个线程。

#### 混合实现

一种方法是使用内核级线程，然后将用户级线程与某些或者全部内核线程多路复用起来。采用这种方法，内核只识别内核级线程，并对其进行调度。其中一些内核级线程会被多个用户级线程多路复用。

#### 调度程序激活机制

调度程序激活机制的目标是模拟内核线程的功能，并具有用户线程的性能和灵活性。

#### 弹出式线程

弹出式线程是指一个消息的到达使系统创建一个处理该消息的线程。这种线程的好处是，每个线程从全新开始，有可能快速创建这类线程。

### 进程间通信

#### 竞争条件

两个或多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序，成为竞争条件。

#### 临界区

把对共享内存进行访问的程序片段称为临界区域。

- 任何两个进程不能同时处于其临界区
- 不应对 CPU 的速度和数量做任何假设

- 临界区外运行的程序不得阻塞其他进程
- 不得使进程无限期等待进入临界区

#### 忙等待的互斥

1. 屏蔽中断
2. 锁变量
3. 严格轮换法
4. Peterson 算法
5. TSL 指令与 XCHG

4 和 5 解法正确，但是会导致忙等待，会导致优先级反转问题。

#### 睡眠与唤醒

生产者 - 消费者问题，有界缓冲区问题。

#### 信号量

#### 互斥量

不需计数的信号量简化版本

#### 管程

为了解决竞争条件、死锁等错误，如 Java 的 synchronized 。

任一时刻管程中只能有一个活跃进程，这使得管程能有效地完成互斥。

#### 消息传递

分布式系统中进程通信的方法，使用 send 和 receive 两条原语。例如：

send(destination, &message); 和 receive(source, &message);

1. 消息传递系统的设计要点

    为了防止消息丢失，一旦接受到信息，接收方马上回送一条特殊的确认消息。如果发送方在一段时间间隔内未收到确认，则重发消息。

    如果确认消息丢失，需要采用在每条原始消息中嵌入一个连续的序号来解决此问题。如果接收者收到一条消息，它具有与前面某一条消息一样的序号，可以直接忽略。

    进程命名问题。

    身份认证问题。

2. 用消息传递解决生产者 - 消费者问题

#### 屏障

#### 避免锁：读 - 复制 - 更新

### 调度

####  调度简介

1. 进程行为

    几乎所有进程的 I/O 请求和计算都是交替突发的。当一个进程等待外部设备完成工作而被阻塞才是 I/O 活动。

    某些进程花费了绝大多数的时间在计算上称为计算密集型，其他进程则在等待 I/O 上花费了绝大多数时间称为 I/O 密集型。

2. 何时调度

    - 在创建一个新进程之后，需要决定是运行父进程还是运行子进程
    - 在一个进程退出时必须做出调度决策
    - 当一个进程阻塞时必须选择另一个进程运行
    - 在一个 I/O 中断发生时必须做出调度决策

3. 调度算法分类

    不同的环境需要不同的调度算法。有以下 3 种环境：

    - 批处理
    - 交互式
    - 实时

4. 调度算法的目标

    - 所有系统
        - 公平——给每个进程公平的 CPU 份额
        - 策略强制执行——保证规定的策略被执行
        - 平衡——保持系统的所有部分都忙碌
    - 批处理系统
        - 吞吐量——每小时最大作业数
        - 周转时间——从提交到终止间的最小时间
        - CPU 利用率——保持 CPU 始终忙碌
    - 交互式系统
        - 响应时间——快速响应请求
        - 均衡性——满足用户需求

    - 实时系统
        - 满足截止时间——避免丢失数据
        - 可预测性——在多媒体系统中避免品质降低

 #### 批处理系统中的调度

 1. 先来先服务
 2. 最短作业优先
 3. 最短剩余时间优先

 #### 交互式系统中的调度

 1. 轮转调度

 2. 优先级调度

 3. 多级队列

 4. 最短进程优先

 5. 保证调度

     平均分配 CPU 时间

 6. 彩票调度

     为进程提供各种系统资源的彩票。一旦需要做出一项调度决策时，就随机抽出一张彩票，拥有该彩票的进程获得该资源。例如，系统可以掌握每秒钟 50 次的一种彩票，作为奖励每个获奖者可以得到 20 ms 的 CPU 时间。更重要的进程可以拥有更多的彩票，以便增加它们获胜的机会。

7. 公平分享调度

    无论一个用户有多少进程存在，每个用户都会得到应有的 CPU 份额。

#### 实时系统中的调度

实时系统是一种时间起着主导作用的系统。计算机必须在一个确定的时间范围内恰当地做出反应。硬实时系统必须满足绝对的截止时间，而软实时系统虽然不希望偶尔错失截止时间，但可以容忍。

实时系统中的事件可以按照响应方式进一步分为周期性和非周期性。

m 为周期事件数，事件 i 以周期 Pi 发生，Ci 为 CPU 处理一个事件的时间，那么可以处理负载的条件是：
$$
\sum \frac {C_i}{P_i} \leq 1
$$
满足这个条件的实时系统称为可调度的。

实时系统的调度算法可以是静态或动态的。前者在系统开始运行之前作出调度决策；后者在运行过程中进行调度决策。

#### 策略和机制

调度机制和调度策略分离，将调度算法以某种形式参数化，参数可以由用户进程填写。这样调度机制位于内核，而调度策略由用户进程决定。

#### 线程调度

用户级线程的线程切换需要少量的机器指令，内核级线程需要完整的上下文切换，修改内存映像，使高速缓存失效，这导致了若干数量级的延迟。内核级线程一旦阻塞在 I/O 上不需要像在用户级线程那样将整个进程挂起。