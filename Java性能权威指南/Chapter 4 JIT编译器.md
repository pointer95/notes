## JIT 编译器

### 调优入门：选择编译器类型

- -client
- -server
- -XX:+TieredCompilation

#### 优化启动

当快速启动时间是首要目标时，最常使用 client 编译器。

分层编译的启动时间可以非常接近于 client 编译器所获得的启动时间。

#### 优化批处理

对于计算量固定的任务来说，应该选择实际执行任务最快的编译器。分层编译是合理的默认选择。

#### 优化长时间运行的应用

应该一直使用 server 编译器，最好配合分层编译。

### 编译器中级调优

#### 调优代码缓存

JVM 编译代码时，会在代码缓存中保留编译之后的汇编语言指令集。代码缓存的大小固定，所以一旦填满，JVM 就不能编译更多代码了。

-XX:ReservedCodeCacheSize=N 标志可以设置代码缓存的最大值。-XX:InitialCodeCacheSize=N 代表代码缓存的初始值。代码缓存从初始值开始，一旦充满就会增加直至最大值。缓存大小的自动调整在后台进行，不会对性能造成实际影响。

#### 编译阈值

当方法和循环执行次数达到某个阈值的时候，就会发生编译。

- 方法调用计数器
- 循环回边计数器

标准编译由 -XX:ComplileThreshold=N 标志触发，修改这个值将使编译器提早或延后编译。

每种计数器的值都会周期性减少（特别是当 JVM 达到安全点时），因此实际上，计数器只是方法或循环最新热度的度量，即便是永远运行的程序，执行不太频繁的代码可能永远不会编译。

#### 检测编译过程

开启 -XX:PrintCompilation 标志可以看到编译器是如何工作的。

### 高级编译调优

不建议修改这些值

#### 编译线程

当方法或循环适合编译时，就会进入到编译队列。队列由一个或多个后台线程处理，这使得代码正在编译的时候，程序也能持续运行。如果是用标准编译所编译的方法，那下次调用该方法时就会执行编译后的方法；如果是用 OSR 编译的循环，那下次循环迭代时就会执行编译后的代码。

编译队列并不严格遵守先进先出的原则：调用计数次数多的方法有更高的优先级。

#### 内联

内联是编译器所能做的最有利的优化，特别是对属性封装良好的面向对象的代码来说。

```java
Point p = getPoint();
p.setX(p.getX() * 2);

// 编译后
Point p = getPoint();
p.x = p.x * 2;
```

#### 逃逸分析

逃逸分析是编译器能做得最复杂的优化。此类优化常常会导致微基准测试失败。

### 逆优化

逆优化意味着编译器不得不撤销之前的某些编译，对应用产生性能降低的影响。

#### 代码被丢弃

- 先前优化的代码不再有效时（例如，所涉及的对象类型发生了改变），才会发生代码逆优化
- 分层编译时，如果代码之前由 client 编译器编译而现在由 server 编译器优化，就会发生逆优化。

#### 逆优化僵尸代码

僵尸代码是指 JVM 已经回收了之前被丢弃的代码。如果发现僵尸代码，这些有问题的代码可以从代码缓存中移除，腾出空间给其他将被编译的代码。

### 分层编译级别

- 0：解释代码
- 1：简单 C1编译代码
- 2：受限的 C1 编译代码
- 3：完全 C1 编译代码
- 4：C2 编译代码

典型的编译日志可以显示，多数方法第一次编译的级别是 3，如果方法运行得足够频繁，它就会编译成级别 4。

如果 server 编译器队列满了，就会从 server 队列中取出方法，以级别 2 进行编译，在这个级别上，C1 编译器使用方法调用计数器和回边计数器。这使得方法编译得更快，而方法也将在 C1 编译器收集分析信息之后被编译为级别 3，最终当 server 编译器队列不太忙的时候被编译为级别 4。

如果 client 编译器全忙，原本排程在级别 3 编译的方法既可以等待级别 3 编译，也可进行级别 4 的编译。在这种情况下，方法编译会很快转到级别 2，然后由级别 2 转到 级别 4。

那些不太重要的方法和 server 编译器出于某些原因无法编译的代码会转为级别 1。

代码在逆编译时转为级别 0。

当方法按期望的顺序，即级别 0 -> 级别 3 -> 级别 4 时，性能可以达到最优。如果方法经常被编译为级别 2，并且还额外有可用的 CPU 周期，可以考虑增加编译器的线程数，从而减少 server 编译器队列的长度。