## 堆内存最佳实践

### 堆分析

#### 内存溢出错误（OOM）

1. 原生内存不足
2. 永久代或元空间内存不足
3. 堆内存不足
4. 达到 GC 开销限制

### 减少内存使用

堆内存用的越少，堆被填满的几率就越低，需要的 GC 周期也越少。

- 减小对象大小
- 延迟初始化
- 尽早清理

#### 不可变对象和标准化对象

不可变对象包括那些有相应的基本类型的类，如 Integer 、Double 和 Boolean 等，以及其他一些基于数值的类型，如 BigDecimal ，还有 String 。

如果不可变对象会快速创建然后丢弃，它们会对 Young GC 多少有些影响，但是影响有限，如果有大量的不可变对象被晋升到老年代，性能就会出现问题。

不可变对象的单一化表示，就被称为对象的标准化（canonical）版本。

通过标准化去掉不可变对象的冗余副本，可以极大减少应用消耗的堆内存。JDK 为大部分常见的不可变对象提供了实现此功能的方法。

#### 字符串的保留

如果应用中有大量字符串是一样的，那通过保留实现字符串重用收效很大。要保留很多字符串的应用可能需要调整字符串保留表的大小。

### 对象生命周期管理

有些情况下，正常的生命周期并不是最优的。有些对象创建的成本很高，而管理这些对象的生命周期可以改进应用的效率，即便以让垃圾收集器多做些工作为代价。

#### 对象重用

对象重用的两种实现方式：

- 对象池
- 线程局部变量

对象池不受待见的原因是：被重用的对象会在堆中停留很长时间。如果有大量对象存在于堆中，那用来创建新对象的空间就少了，因为 GC 操作会更频繁。但是一旦对象晋升到老年代，执行一次 Full GC 所花的时间与老年代种仍然存活的对象数量成正比，导致引发的性能问题甚至更多。

需要对象重用的情况：

- 很多对象初始化成本很高，与增加的 GC 时间这一点相权衡，重用更加高效
- 初始化对象需要的时间较长
- 所共享对象的数目很小，还不足以降低 GC 周期

1. 对象池

   对象池的性能受以下几个因素影响：

   - GC 影响：保存大量对象会降低 GC 影响
   - 同步：必然同步
   - 限流：对于堆稀缺资源的访问，线程池可以起到限流作用

2. 线程局部变量

   - 生命周期管理：线程局部变量要比在池中管理对象更容易，成本更低。
   - 基数性（Cardinality）：线程局部变量通常会伴生线程数与保存的可重用对象数之间的一一对应关系，而对象池的大小则有些随意。
   - 同步：不需要同步。

#### 弱引用、软引用与其他引用

非确定引用（Indefinite reference）用来区分强引用和其他特殊引用。

非确定引用的工作方式是，在非确定引用类的实例内，嵌入另一个引用（几乎总是嵌入一个强引用）。被封装的对象称为所引对象（Referent）。

与对象池或线程局部变量相比，非确定引用的优势在于，它们最终会被垃圾收集器回收。缺点是对垃圾收集器的效率会有以下轻微影响：

- 导致应用使用更多内存。对垃圾收集器的更大的影响体现为，垃圾收集器要回收非确定引用，至少需要两个 GC 周期。

1. 软引用

    如果对象以后有很大的机会重用，可以使用软引用。但如果该对象近期一直没有使用到，垃圾收集器会回收它。软引用本质上是一个比较大的、最近未使用（LRU）的对象池。

    软引用被释放的条件：

    - 所引对象一定不能有其他的强对象
    - 堆中空闲内存的数量

2. 弱引用

    当所引对象同时被几个线程使用时，应该考虑弱引用。否则，弱引用很可能会被垃圾收集器回收。只有弱引用的对象在每个 GC 周期都可以回收。当强引用被移除时，弱引用会立即释放。如果弱引用的所引对象存在了足够长的时间，被提升到了老年代，则弱引用在下一次并发或 Full GC 周期内才会释放。

3. 终结器（Finalizer）和最终引用（Final Reference）