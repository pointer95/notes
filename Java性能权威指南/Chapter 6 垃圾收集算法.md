## 垃圾收集算法

### 理解 Throughput 收集器

Throughput 收集器会进行 Minor GC 和 Full GC 两种操作。

#### 堆大小的自适应调整和静态调整

-XX:MaxGCPauseMills=N 标志用于设定应用承受的最大停顿时间。

-XX:GCTimeRatio=N 标志可以设置应用程序在垃圾回收上花费多少时间。

对很多的应用程序而言，采用动态调整就已经足够，动态调整的配置能够有效地减少 JVM 的内存使用。

静态地设置堆地大小也可能获得最优地性能。

### 理解 CMS 收集器

CMS 收集器有 3 种基本的操作，分别是：

- Minor GC
- 启动一个并发地线程对老年代空间的垃圾进行回收
- 如果有必要，会发起 Full GC

CMS 收集过程中的并发模式失效以及晋升失败的代价都非常昂贵，应该尽量调优 CMS 收集器以避免发生这些情况。

默认情况下不会对永久代进行垃圾回收，当永久代空间用尽时，需要回收时，才会发生 Full GC。

#### 针对并发模式失效的调优

发生并发模式失效往往是由于 CMS 不能以足够快的速度清理老年代：新生代发生垃圾回收，同时老年代有没有足够的空间容纳晋升的对象，不得不先对老年代进行垃圾回收，CMS 垃圾回收就会退化成 Full GC。

有以下途径可以避免发生这种失效：

1. 更好的方案是增加堆的大小，使得老年代空间增加

2. 给后台线程更多的运行机会

   同时设置 -XX:CMSInitiatingOccupancyFaction=N 和 -XX:+UseCMSInitiatingOccupancyOnly 这两个标志，尽早启动并发后台线程的运行。

3. 调整 CMS 后台线程

   -XX:ConcGCThreads=N 标志增加后台线程的数目。默认情况下，ConcGCThreads 的值是依据 ParallelGCThreads 标志的值计算得到：ConcGCThreads = (3 + ParallelGCThreads ) / 4

   调整这一标志的要点在于判断是否有可用的 CPU 周期。如果 ConcGCThreads  设置得值偏大，垃圾收集会占用本来能用于运行应用线程的 CPU 周期。

#### CMS 收集器的永久代调优

Java 8 中，CMS 收集器默认就会收集元空间中不再载入的类。

### 理解 G1 垃圾收集器

G1 收集器的收集活动主要包括：

- 新生代垃圾收集
- 后台收集，并发周期
- 混合式垃圾收集
- 必要时的 Full GC

需要进一步调优的 4 种情况：

- 并发模式失效

  G1 垃圾收集启动标记周期，但老年代在周期完成之前就被填满，在这种情况下，G1 收集器会放弃标记周期，触发 Full GC。发生这种失败意味着堆的大小应该增加了，或者 G1 收集器的后台处理应该更早开始，或者是需要调整周期，让它运行得更快。

- 晋升失败

  G1 收集器完成了标记阶段，开始启动混合式垃圾回收清理老年代分区，不过，老年代空间在垃圾回收释放出足够内存之前就会被耗尽。这种失败意味着混合式收集需要更迅速地完成垃圾收集；每次新生代垃圾收集需要处理更多老年代地分区。

- 疏散失败

  进行新生代垃圾收集时，Survivor 空间和老年代中没有足够的空间容纳所有的幸存对象。这种情况表明已经几乎完全用尽或者碎片化了。

- 巨型对象分配失败

  使用 G1 收集器时，分配非常巨大对象的应用程序可能遭遇另一种 Full GC。

#### G1 垃圾收集器调优

调优的主要目标是避免发生并发模式失败或者疏散失败，一旦发生这些失败就会导致 Full GC。其次，调优可以使过程中的停顿时间最小化。下面所列的方法都能避免发生 Full GC ：

- 通过增加总的堆大小或者调整老年代、新生代之间的比例来增加老年代空间的大小
- 增加后台线程的数目
- 以更高的频率进行 G1 的后台垃圾收集活动、
- 在混合式垃圾回收周期中完成更多的垃圾收集工作

最主要是的调优只有通过一个标志进行：-XX:MaxGCPauseMills=N

如果减小参数值，为了达到停顿时间的目标，新生代的大小会相应减小，不过新生代垃圾收集的频率会更加频繁。除此之外，为了达到停顿时间的目标，混合式 GC 收集的老年代分区数也会减少，而这会增大并发模式失败发生的机会。

如果设置停顿时间无法避免 Full GC ，我们可以进一步针对不同的方面逐一调优。

1. 调整 G1 垃圾收集的后台线程数

2. 调整 G1 垃圾收集器运行的频率

   G1 垃圾收集周期通常在堆的占用达到参数 -XX:InitiatingHeapOccupancyPercent=45 时启动。注意，跟 CMS 收集器不一样，这个参数值的依据时整个堆的使用情况，而不是老年代的。

3. 调整 G1 收集器的混合式垃圾收集周期

   并发周期之后、老年代的标记分区回收完成之前，G1 收集器无法启动新的并发周期。因此，让 G1 收集器更早启动标记周期的另一个方法是在混合式垃圾回收周期中尽量处理更多的分区，如此一来最终的混合式 GC 周期就变少了。

   混合式垃圾收集要处理的工作量取决于三个因素：

   - 有多少分区被发现大部分是垃圾对象
   - G1 垃圾收集回收分区时的最大混合式 GC 周期数，通过 -XX:G1MixedGCCountTarget=N 调节。
   - GC 停顿可忍受的最大时长

### 高级调优

#### 晋升及 Survivor 空间

为了让对象在新生代停留更多的 GC 周期，增大对象晋升老年代之前被回收释放的纪律。如果 Survivor 空间过小，对象会直接晋升到老年代，从而触发更多的 Full GC。

如果对象的生命周期很长，跨越多个垃圾收集周期，无论怎样调整它们最终都会移动到老年代，在这种情况下，跳这个 Survivor 空间和晋升阈值都不会由太大的帮助。但是，如果对象经过几个 GC 周期就会被回收，合理安排 Survivor 空间更高效地加以利用，能够提升一定的程序性能。

最好的解决方法是增大堆的大小，让 JVM 来处理 Survivor 空间的回收。