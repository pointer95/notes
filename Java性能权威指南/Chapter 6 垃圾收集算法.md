## 垃圾收集算法

### 理解 Throughput 收集器

Throughput 收集器会进行 Minor GC 和 Full GC 两种操作。

#### 堆大小的自适应调整和静态调整

-XX:MaxGCPauseMills=N 标志用于设定应用承受的最大停顿时间。

-XX:GCTimeRatio=N 标志可以设置应用程序在垃圾回收上花费多少时间。

对很多的应用程序而言，采用动态调整就已经足够，动态调整的配置能够有效地减少 JVM 的内存使用。

静态地设置堆地大小也可能获得最优地性能。

### 理解 CMS 收集器

CMS 收集器有 3 种基本的操作，分别是：

- Minor GC
- 启动一个并发地线程对老年代空间的垃圾进行回收
- 如果有必要，会发起 Full GC

CMS 收集过程中的并发模式失效以及晋升失败的代价都非常昂贵，应该尽量调优 CMS 收集器以避免发生这些情况。

默认情况下不会对永久代进行垃圾回收，当永久代空间用尽时，需要回收时，才会发生 Full GC。

#### 针对并发模式失效的调优

发生并发模式失效往往是由于 CMS 不能以足够快的速度清理老年代：新生代发生垃圾回收，同时老年代有没有足够的空间容纳晋升的对象，不得不先对老年代进行垃圾回收，CMS 垃圾回收就会退化成 Full GC。

有以下途径可以避免发生这种失效：

1. 更好的方案是增加堆的大小，使得老年代空间增加

2. 给后台线程更多的运行机会

   同时设置 -XX:CMSInitiatingOccupancyFaction=N 和 -XX:+UseCMSInitiatingOccupancyOnly 这两个标志，尽早启动并发后台线程的运行。

3. 调整 CMS 后台线程

   -XX:ConcGCThreads=N 标志增加后台线程的数目。默认情况下，ConcGCThreads 的值是依据 ParallelGCThreads 标志的值计算得到：ConcGCThreads = (3 + ParallelGCThreads ) / 4

   调整这一标志的要点在于判断是否有可用的 CPU 周期。如果 ConcGCThreads  设置得值偏大，垃圾收集会占用本来能用于运行应用线程的 CPU 周期。

#### CMS 收集器的永久代调优

Java 8 中，CMS 收集器默认就会收集元空间中不再载入的类。

### 理解 G1 垃圾收集器

G1 收集器的收集活动主要包括：

- 新生代垃圾收集
- 后台收集，并发周期
- 混合式垃圾收集
- 必要时的 Full GC

需要进一步调优的 4 种情况：

- 并发模式失效

  G1 垃圾收集启动标记周期，但老年代在周期完成之前就被填满，在这种情况下，G1 收集器会放弃标记周期，触发 Full GC。发生这种失败意味着堆的大小应该增加了，或者 G1 收集器的后台处理应该更早开始，或者是需要调整周期，让它运行得更快。

- 晋升失败

  G1 收集器完成了标记阶段，开始启动混合式垃圾回收清理老年代分区，不过，老年代空间在垃圾回收释放出足够内存之前就会被耗尽。这种失败意味着混合式收集需要更迅速地完成垃圾收集；每次新生代垃圾收集需要处理更多老年代地分区。

- 疏散失败

  进行新生代垃圾收集时，Survivor 空间和老年代中没有足够的空间容纳所有的幸存对象。这种情况表明已经几乎完全用尽或者碎片化了。

- 巨型对象分配失败

  使用 G1 收集器时，分配非常巨大对象的应用程序可能遭遇另一种 Full GC。

#### G1 垃圾收集器调优

调优的主要目标是避免发生并发模式失败或者疏散失败，一旦发生这些失败就会导致 Full GC。其次，调优可以使过程中的停顿时间最小化。下面所列的方法都能避免发生 Full GC ：

- 通过增加总的堆大小或者调整老年代、新生代之间的比例来增加老年代空间的大小
- 增加后台线程的数目
- 以更高的频率进行 G1 的后台垃圾收集活动、
- 在混合式垃圾回收周期中完成更多的垃圾收集工作

最主要是的调优只有通过一个标志进行：-XX:MaxGCPauseMills=N

如果减小参数值，为了达到停顿时间的目标，新生代的大小会相应减小，不过新生代垃圾收集的频率会更加频繁。除此之外，为了达到停顿时间的目标，混合式 GC 收集的老年代分区数也会减少，而这会增大并发模式失败发生的机会。

如果设置停顿时间无法避免 Full GC ，我们可以进一步针对不同的方面逐一调优。

1. 调整 G1 垃圾收集的后台线程数

2. 调整 G1 垃圾收集器运行的频率

   G1 垃圾收集周期通常在堆的占用达到参数 -XX:InitiatingHeapOccupancyPercent=45 时启动。注意，跟 CMS 收集器不一样，这个参数值的依据时整个堆的使用情况，而不是老年代的。

3. 调整 G1 收集器的混合式垃圾收集周期

   并发周期之后、老年代的标记分区回收完成之前，G1 收集器无法启动新的并发周期。因此，让 G1 收集器更早启动标记周期的另一个方法是在混合式垃圾回收周期中尽量处理更多的分区，如此一来最终的混合式 GC 周期就变少了。

   混合式垃圾收集要处理的工作量取决于三个因素：

   - 有多少分区被发现大部分是垃圾对象
   - G1 垃圾收集回收分区时的最大混合式 GC 周期数，通过 -XX:G1MixedGCCountTarget=N 调节。
   - GC 停顿可忍受的最大时长

### 高级调优

#### 晋升及 Survivor 空间

为了让对象在新生代停留更多的 GC 周期，增大对象晋升老年代之前被回收释放的纪律。如果 Survivor 空间过小，对象会直接晋升到老年代，从而触发更多的 Full GC。

如果对象的生命周期很长，跨越多个垃圾收集周期，无论怎样调整它们最终都会移动到老年代，在这种情况下，跳这个 Survivor 空间和晋升阈值都不会由太大的帮助。但是，如果对象经过几个 GC 周期就会被回收，合理安排 Survivor 空间更高效地加以利用，能够提升一定的程序性能。

最好的解决方法是增大堆的大小，让 JVM 来处理 Survivor 空间的回收。

#### 分配大对象

1. TLAB

    线程本地分配缓冲区（Thread Local Allocation Buffer，TLAB）的大小是各种垃圾收集算法进行垃圾收集时都要考虑的因素。

    在 Eden 空间中对象分配速度更快的原因是每个线程都有一个固定的分区用于分配对象，即一个 TLAB。对象在一个共享的空间中分配，需要采用一些同步机制来管理空间内的空闲空间指针。每个线程有固定的分配区域，分配对象时，线程之间不需要任何的同步。

    TLAB 都不大，因此大型对象无法在 TLAB 内进行分配，而是必须直接从堆上分配，由于需要同步，将会消耗额外的时间。

    TLAB 的大小由三个因素决定：应用程序的线程数、Eden 空间的大小以及线程的分配率。因此两类的应用程序会受益于 TLAB 参数的调整：需要分配大量巨型对象的应用程序，以及相对于 Eden 空间的大小而言，应用程序线程数量过多的应用。

2. 调整 TLAB 的大小

    使用 -XX:TLABSize=0 标志可以显式地指定 TLAB 的大小，这个标志只能设置 TLAB 的初始大小。为了避免在每次 GC 时都调整 TLAB 的大小，可以使用 -XX:ResizeTLAB 标志。

    TLAB 的日志的输出中，refill waste 的值代表了决策的当前阈值：如果 TLAB 无法容纳新对象的大小超过了这个阈值，那么就会在堆上分配新的对象；如果有问题的对象的大小比这个阈值小，就回收老的 TLAB 空间。

3. 巨型对象（Humongous Objects）

    TLAB 无法分配的对象，JVM 会尽量尝试在 Eden 空间中进行分配。如果 Eden 空间无法容纳该对象，就只能在老年代中分配空间。如果它是一个短期存在的对象，还会对垃圾收集造成负面的影响。

    G1 收集器使用不同的方法处理巨型对象，不过如果对象的大小超过了 G1 收集器的分区，这些对象也会被分到老年代。

4. G1 分区的大小

    分区大小 = 1 << log(初始堆的大小 / 2048)

    通过 -XX:G1HeapRegionSize=0 标志设置

5. 使用 G1 收集器分配巨型对象

    增大 G1 分区的大小，让其能够在一个分区内分配应用需要的所有对象能提升 G1 收集的效率。

    如果堆无法为新的巨型对象提供连续的分区，G1 收集器只能进行 Full GC。

