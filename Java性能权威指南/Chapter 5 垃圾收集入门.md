## 垃圾收集入门

### 垃圾收集概述

#### GC 算法

- Serial 垃圾收集器
- Throughput 垃圾收集器
- CMS 垃圾收集器
- G1 垃圾收集器

#### 选择 GC 算法

1. GC 算法及批量任务

   使用 Thoughput 收集器处理应用程序线程的批量任务能最大程度地利用 CPU 的处理能力，通常能获得更好的性能。如果批量任务并没有使用机器上所有可用的 CPU 资源，那么切换到 Concurrent 收集器往往能取得更好的性能。

2. GC 算法和吞吐量测试

3. GC 算法和相应时间测试

   衡量标准是响应时间或吞吐量，在 Thoughput 收集器和 Concurrent 收集器之间做选择的依据主要是有多少空闲 CPU 资源能用于运行后台的并发线程。通常情况下，Thoughput 收集器的平均响应时间比 Concurrent 收集器要差，但是在 90% 响应时间或者 99% 响应时间这几项指标上，Thoughput 收集器比 Concurrent 收集器要好一些。使用 Thoughput 收集器会超负荷地进行大量 Full GC 时，切换到 Concurrent 收集器通常能获得更低的响应时间。

4. CMS 收集器和 G1 收集器之间的抉择

   如果堆较小，推荐使用 CMS 收集器。G1 的设计使得它能够在不同的分区（Region）处理堆，因此它的扩展性更好，比 CMS 更易于处理超大堆的情况。

### GC 调优基础

#### 调整堆的大小

如果分配的堆过于小，程序的大部分时间可能都消耗在 GC 上，没有足够的时间去运行应用程序的逻辑。如果分配的堆过大，GC 停顿的持续时间也会变长。

如果分配的堆大小超过了物理内存的大小，JVM 填满了分配给它的堆空间，就会导致严重的性能问题，因为操作系统需要将相当一部分的数据由磁盘交换到内存。当 Full GC 时发生内存交换，停顿时间会以正常停顿时间数个量级的方式增长。因此永远不要将堆的容量设置得比机器的物理内存还大，如果一台机器上运行着多个 JVM 实例，这个原则适用于所有堆的总和。并且还要为 JVM 自身以及机器上其他应用程序预留一部分的内存空间。

-Xms N 设置堆的初始值，-Xmx N 设置堆的最大值。当且仅当应用程序需要更多的内存（依据垃圾回收消耗的时间决定）时将堆的大小增大到一个合理的最大值。

#### 代空间的调整

-XX:NewRatio=N 设置新生代与老年代的空间占用比率，默认值为 2

根据公式 Initial Young Gen Size = Initial Heap Size / (1 + NewRatio) 得到新生代空间的大小

-XX:NewSize=N 设置新生代空间的初始大小

-XX:MaxNewSize=N 设置新生代空间的最大大小

-XmnN 将 NewSize 和 MaxNewSize 设定为同一个值的快捷方法

如果堆的大小是固定的，通常推荐使用 -Xmn 标志将新生代也设定为固定大小。如果应用程序需要动态调整堆的大小，并希望有一个更大的或者更小的新生代，那就需要关注 NewRatio 值的设定。

#### 永久代和元空间的调整

永久代或元空间保存着类的元数据。

-XX:PermSize=N、-XX:MaxPermSize=N 标志调整永久代大小

-XX:MetaspaceSize=N、-XX:MaxMetaspaceSize=N 标志调整元空间大小

如果程序在启动时发生大量的 Full GC，通常都是由于永久代或者元空间发生了大小调整，因此这种情况下为了改善启动速度、增大初始值是个不错的主意。

#### 控制并发

-XX:ParallelGCThreads=N 调整启动的线程数。对下面这些操作，这个参数值会影响线程的数目：

- 使用 -XX:+UseParallelGC 收集新生代空间
- 使用 -XX:+UseParallelOldGC 收集老年代空间
- 使用 -XX:+UseParNewGC 收集新生代空间
- 使用 -XX:+UseG1GC 收集新生代空间
- CMS 收集器的 Stop the World 阶段（非 Full GC）
- G1 收集器的 Stop the World 阶段（非 Full GC）

总的线程数为（N 为 CPU 数目）：ParallelGCThreads = 8 + ((N - 8) * 5 / 8)

如果机器上同时运行了多个 JVM 实例，需要限制所有 JVM 使用的线程总数。

#### 自适应调整

JVM 进行性能调优的依据是根据以往的性能历史：即将来 GC 周期的状况跟最近历史 GC 周期的状况可能很类似。

自适应调整可以：

- 小型应用程序不需要再为指定了过大的堆而担心
- 很多应用程序根本不需要担心它们堆的大小

对于已经精细调优过的堆，关闭自适应调整能获得一定的性能提升。